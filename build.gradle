plugins {
	id "java"
	id "maven-publish"
	id "com.diffplug.spotless" version "6.4.1"
	// https://github.com/tbroyer/gradle-errorprone-plugin
	id 'net.ltgt.errorprone' version '2.0.2'
}

repositories {
	mavenCentral()
	mavenLocal()
}

configurations {
	javacJar
	// for putting Error Prone javac in bootclasspath for running tests
	errorproneJavac
	// local dependency
	localDeps
}

ext.versions = [
	checkerFramework: "3.21.3-eisop1",
	errorproneJavacVersion: "9+181-r4173-1",
	errorproneCoreVersion: "2.11.0",
]

sourceCompatibility = 1.8
def checkerframework_local = false  // Set this variable to [true] while using local version of checker framework.
def CHECKERFRAMEWORK = System.getenv("CHECKERFRAMEWORK")

dependencies {
	// This dependency is found on compile classpath of this component and consumers.
	if (checkerframework_local) {
		if (CHECKERFRAMEWORK == null) {
			CHECKERFRAMEWORK = "../checker-framework/"
		}
		implementation files("${CHECKERFRAMEWORK}/checker/dist/checker-qual.jar")
		localDeps files("${CHECKERFRAMEWORK}/checker/dist/checker.jar")
	} else {
		localDeps "io.github.eisop:checker:${versions.checkerFramework}"
		localDeps "io.github.eisop:checker-qual:${versions.checkerFramework}"
		localDeps "io.github.eisop:checker-util:${versions.checkerFramework}"
	}
	implementation configurations.localDeps

	if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
		javacJar group: 'com.google.errorprone', name: 'javac', version: "${versions.errorproneJavacVersion}"
	}
	errorprone "com.google.errorprone:error_prone_core:${versions.errorproneCoreVersion}"
	errorproneJavac "com.google.errorprone:javac:${versions.errorproneJavacVersion}"

	// Testing
	testImplementation "junit:junit:4.13.2"
	testImplementation "io.github.eisop:framework-test:${versions.checkerFramework}"

}

sourceSets {
	main {
		java {
			srcDirs = ["src/main/java"]
		}

		resources {
			srcDirs = ["src/main/java"]
			exclude "**/*.java"
		}
	}

	test {
		java {
			srcDirs = ["src/test/java"]
			if (!checkerframework_local) {
				exclude "tests/PropertyFileTest.java"
			}
		}
	}
}

tasks.withType(JavaCompile).all {
	options.compilerArgs.add("-Xlint:all")
}

spotless {
	java {
		target "src/**/*.java", "tests/**/*.java"
		googleJavaFormat().aosp()
		removeUnusedImports()
	}
	format "misc", {
		target "**/*.gradle", "**/.gitignore"
		trimTrailingWhitespace()
		indentWithTabs()
		endWithNewline()
	}
}

// Run `./gradlew publishToMavenLocal` to publish your checker to your local Maven repository.
publishing {
	publications {
		maven(MavenPublication) {
			groupId = "io.github.eisop"
			artifactId = "crypto-checker"
			version = "0.1-SNAPSHOT"
			from components.java
			if (checkerframework_local) {
				pom.withXml {
					def dependenciesNode = asNode().appendNode('dependencies')
					def dependencyNode = dependenciesNode.appendNode('dependency')
					dependencyNode.appendNode("groupId", "io.github.eisop")
					dependencyNode.appendNode("artifactId", "checker")
					dependencyNode.appendNode("version", "${versions.checkerFramework}")
					dependencyNode.appendNode("systemPath", projectDir.toString() + "$buildDir/libs/checker.jar")
				}
			}
		}
	}
}

test {
	if (!JavaVersion.current().java9Compatible) {
		jvmArgs "-Xbootclasspath/p:${configurations.errorproneJavac.asPath}"
	}
}

test.dependsOn(":assemble")
assemble.dependsOn(":spotlessApply")

afterEvaluate {
	// Configure JUnit tests
	tasks.withType(Test) {
		testLogging {
			// Always run the tests
			outputs.upToDateWhen { false }
			// The following prints out each time a test is passed.
			events "passed", "skipped", "failed", "standardOut", "standardError"
			// Show the found unexpected diagnostics and expected diagnostics not found.
			exceptionFormat "full"
			showExceptions true
			showCauses true
			showStackTraces true
			showStandardStreams true
		}
		// After each test, print a summary.
		afterSuite { desc, result ->
			if (desc.getClassName() != null) {
				long mils = result.getEndTime() - result.getStartTime()
				double seconds = mils / 1000.0
				println()
				println "Testsuite: ${desc.getClassName()}\n" +
						"Tests run: ${result.testCount}, " +
						"Failures: ${result.failedTestCount}, " +
						"Skipped: ${result.skippedTestCount}, " +
						"Time elapsed: ${seconds} sec"
			}
		}
	}

	tasks.withType(JavaCompile) { compilationTask ->
		// Sorting is commented out because it disables incremental compilation.
		// Uncomment when needed.
		// // Put source files in deterministic order, for debugging.
		// compilationTask.source = compilationTask.source.sort()
		sourceCompatibility = 8
		targetCompatibility = 8
		// Because the target is 8, all of the public compiler classes are accessible, so
		// --add-exports are not required, (nor are they allowed with target 8). See
		// https://openjdk.java.net/jeps/247 for details on compiling for older versions.

		// When sourceCompatibilty is changed to 11, then the following will be required.
		// options.compilerArgs += [
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
		// "--add-exports", "jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
		// ]
		// This is equivalent to writing "exports jdk.compiler/... to ALL-UNNAMED" in the
		// module-info.java of jdk.compiler, so corresponding --add-opens are only required for
		// reflective access to private members.
		//
		// From https://openjdk.java.net/jeps/261, Section titled: "Breaking encapsulation"
		// "The effect of each instance [of --add-exports] is to add a qualified export of the
		// named package from the source module to the target module. This is, essentially, a
		// command-line form of an exports clause in a module declaration[...].
		// [...]
		// The --add-exports option enables access to the public types of a specified package.
		// It is sometimes necessary to go further and enable access to all non-public elements
		// via the setAccessible method of the core reflection API. The --add-opens option can
		// be used, at run time, to do this."

		options.failOnError = true
		options.deprecation = true
		options.compilerArgs += [
				'-g',
				'-Werror',
				// -options: To not get a warning about missing bootstrap classpath for Java 8 (once we use Java 9).
				// -fallthrough: Don't check fallthroughs.  Instead, use Error Prone.  Its
				// warnings are suppressible with a "// fall through" comment.
				"-Xlint:-options,-fallthrough",
				"-Xlint",
		]

		options.encoding = 'UTF-8'
		options.fork = true
		if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
			options.forkOptions.jvmArgs += ["-Xbootclasspath/p:${configurations.javacJar.asPath}".toString()]
			options.errorprone.enabled = false
		} else {
			options.errorprone.enabled = true
		}
	}
}

clean.doFirst {
	delete "${rootDir}/tests/build/",
			fileTree("tests/") { include "**/*.class" },
			"${rootDir}/benchmarks/androidKeyStoreProject"
}

test.doLast {
	delete "${rootDir}/tests/build/",
			fileTree("tests/") { include "**/*.class" }
}

task copyDependencies(type: Copy) {
	from configurations.localDeps
	into "$buildDir/libs"
}

task printLocalCheckerFrameworkPath() {
	println CHECKERFRAMEWORK
}
